---
title: "beautiful graphics ggplot2"
author: "C.J. Liu"
date: "11/17/2016"
output: 
    html_document:
        toc: true
        toc_float:
            collapsed: false
            smooth_scroll: false
        depth: 3
        theme: united
        number_sections: true
        highlight: tango
---

# Plot One Variable - X: Continuous or Discrete

For **one continuous variable** = **Numeric**:

* geom_area()
* geom_density()
* geom_histogram()
* geom_freqpoly()
* geom_dotplot()
* stat_ecdf()
* stat_qq()

For **one discrete varaible** = **Factor**:

* geom_bar()

```{r load library}
library(ggplot2)
library(dplyr)
```


## Area Plots
**alpha, color, fill, linetype, size**
```{r}
set.seed(1234)
wdata = as_data_frame(data.frame(sex = factor(rep(c("F", "M"), each=200)), weight = c(rnorm(200,55),rnorm(200,58))))
wdata

mu <- wdata %>% group_by(sex) %>% summarize(grp.mean = mean(weight))
mu

a <- ggplot(wdata, aes(x = weight))

a + geom_area(stat = "bin", color = "black", fill = "#00AFBB")
#a + geom_area() will not get right result, object 'y' not found. Use stat to specify the count as y 
#Note that, by default y axis corresponds to the count of weight values. If you want to change the plot in order to have the density on y axis, the R code would be as follow.
a + geom_area(aes(y = ..density..), stat = "bin")

data("diamonds")
diamonds <- as_data_frame(diamonds)
diamonds
p <- ggplot(diamonds, aes(x = price, fill = cut))
# Bar plot
p + geom_bar(stat = "bin")
# Area plot
p + geom_area(stat = "bin")
```

## Density Plots
**alpha, color, fill, linetype, size**

* scale_color_manual(), scale_fill_manual()
* scale_color_brewer(), scale_fill_brewer() RColor-Brewer
* scale_color_grey(), scale_fill_grey()


```{r}
# Basic plots
a + geom_density()

# Add color and mean xintercept and median xintercept
a + geom_density(color = "black", fill = "gray") + geom_vline(aes(xintercept = mean(weight)), color = "#FC4E08", linetype = "dashed", size = 1) + geom_vline(aes(xintercept = median(weight)), color = "blue", linetype = 4, size = 1)

# Change color by group
a + geom_density(aes(fill = sex), alpha = 0.4) 

# Add mean lines and color by sex
a + geom_density(aes(fill = sex), alpha = 0.4) + geom_vline(data = mu, aes(xintercept = grp.mean, color = sex), linetype = "dashed")

# Change manually 
# change line manually
a2 <- a + geom_density(aes(color = sex)) + geom_vline(data = mu, aes(xintercept = grp.mean, color = sex), linetype = "dashed") + theme_minimal()

a2 + scale_color_manual(values = c("#999999", "#E69F00"))

a2 + scale_color_brewer(palette = "Paired")

a2 + scale_color_grey()

# change fill manually
a3 <- a + geom_density(aes(fill = sex), alpha = 0.4) + theme_minimal()

a3 + scale_fill_manual(values = c("#999999", "#E69F00"))

a3 + scale_fill_brewer(palette = "Dark2")

a3 + scale_fill_grey()
```

## Histogram Plots
**identity(position\_identity()), stack(position\_stack()), dodge(position\_dodge()); Default values is "stack"**

**alpha, color, fill, linetype, size**
```{r}
# Basic plot
a + geom_histogram()

a + geom_histogram(bins = 50)

#Note that by default, stat_bin uses 30 bins - this might not be good default. You can change the number of bins (e.g.: bins = 50 or the bin width e.g.: binwidth = 0.5.
a + geom_histogram(bins = 50, color = "black", fill = "grey") + geom_vline(aes(xintercept = mean(weight)), color = "#FC4E07", linetype = "dashed", size = 1) + theme_minimal()

a + geom_histogram(aes(y = ..density..), bins = 50)

# Change color by sex
a + geom_histogram(aes(color = sex), fill = "white", bins = 50) + theme_minimal()

# Position adjustment "identity"(overlaid)
a + geom_histogram(aes(color = sex), fill = "white", bins = 50, alpha = 0.6, position = "identity")

# Position adjustment "dodge" (Interleaved)
# Add mean lines and color by sex
a + geom_histogram(aes(color = sex), fill = "white", alpha = 0.6, position = "dodge", bins = 50) + geom_vline(aes(xintercept = mean(weight)), linetype = "dashed")

# Change fill, color manually
# Change outline color manually
a + geom_histogram(aes(color = sex), fill = "white", alpha = 0.4, position = "identity", bins = 50) + scale_color_manual(values = c("#00AFBB","#E7B800"))

# Change fill and outline color manually
# a + geom_histogram(aes(color = sex), fill = "white", alpha =0.4, position = "identity", bins = 50) + scale_fill_manual(values = c("#00AFBB", "#E7B800")) + scale_color_manual(values = c("#00AFBB", "#E7B800")) 
# wrong command, I have to assign fill first by group

a + geom_histogram(aes(color = sex, fill = sex), alpha =0.4, position = "identity", bins = 50) + scale_fill_manual(values = c("#00AFBB", "#E7B800")) + scale_color_manual(values = c("#00AFBB", "#E7B800")) 


## Combine Histogram and Density Plots

# Plot histogram with density values on y-axis(instead of count values).
# Add density plot with transparent density plot

# Histogram with density plot
a + geom_histogram(aes(y = ..density..),color = "black", fill = "white") + geom_density(alpha = 0.2, fill = "#FF6666") + theme_minimal()

# Color by groups
a + geom_histogram(aes(y = ..density.., color = sex, fill = sex),  alpha = 0.4, position = "identity") + geom_density(aes(color = sex), size =1)


```

## Frequency Polygon
Very close to histogram plots

* Histogram use bars
* Frequency polygons use lines.

**alpha, color, linetype, size**
```{r}
# Basic plot
a + geom_freqpoly(bins = 30) + theme_minimal()

# Change color and linetype by sex
# Use custom color palettes
a + geom_freqpoly(aes(color = sex, linetype = sex), bins = 30 ) +  scale_color_manual(values = c("#999999", "#E69F00"))+theme_minimal()

# y density
a + geom_freqpoly(aes(y = ..density.., color = sex, linetype = sex), bins = 30 ) +  scale_color_manual(values = c("#999999", "#E69F00"))+theme_minimal()
```

## Dot Plots for One Variable
Not suitable for one variable, it's ugly.
```{r}
a + geom_dotplot(aes(fill = sex))
```

## ECDF Plots
Empirical Cumulative Density Function

**alpha, color, linetype, size**

```{r}
a + stat_ecdf(geom = "point")

a + stat_ecdf(geom = "step")
```

## QQ Plots
Quantile - Quantie plots to chech whether a given data follows normal distribution.

**alpha, color, shape, size**
```{r}
data(mtcars)
mtcars <- as_data_frame(mtcars)
mtcars
mtcars <- mutate(mtcars, cyl = as.factor(cyl))
mtcars

p <- ggplot(mtcars, aes(sample = mpg))

# Basic plot
p + stat_qq()

# Change point shapes by groups
# Use custom color palettes
p + stat_qq(aes(shape = cyl, color = cyl)) + scale_color_manual(values = c("#00AFBB", "#E7B800", "#FC4E07"))
```

## Bar Plots of Counts
For one discrete variable

**alpha, color, fill, linetype, size**

```{r}
data(mpg)
mpg <- as_data_frame(mpg)
mpg

ggplot(mpg, aes(fl)) + geom_bar(fill = "steelblue") + theme_minimal()
```


# Plot Two Variables -X & Y: Both Continuous or Discrete

## Scatter plots: Continuous X and Y

* geom_pint()
* geom_smooth()
* geom_quantile()
* geom_rug()
* geom_jitter()
* geom_text()

geom_point  
**alpha, color, fill, shape, size**
```{r}
# Data format
mtcars
b <- ggplot(mtcars, aes(x = wt, y= mpg))
# x weight
# y miles/gallon
#Basic scatter plots
b + geom_point(color = "#00AFBB")

# Change the point size, and shape
b + geom_point(color = "#00AFBB", size = 2, shape = 23)

# Control point size by continuous variable values
# qsec 1/4 mile time
b + geom_point(aes(size = qsec), color = "#00AFBB")

# Label text
b + geom_point() + geom_text(label = rownames(mtcars), nudge_y = 0.8)

# Change shape, color, size automatically
# Change point shape by the level of cyl
b + geom_point(aes(shape = cyl))

# Change point shape and colors
b + geom_point(aes(color = cyl, shape = cyl))

# Change shape, color, size manually
# Change the point sizes manually
b + geom_point(aes(color = cyl, shape = cyl, size = cyl)) + scale_size_manual(values = c(2,3,4))

# Change the point shapes and colors manually
b + geom_point(aes(color = cyl, shape = cyl)) + scale_shape_manual(values = c(3,16,17)) + scale_color_manual(values = c('#999999','#E69F00', '#56B4E9'))

# Use brewer color palettes
b + geom_point(aes(color = cyl, shape = cyl)) + scale_color_brewer(palette = "Dark2") + theme_minimal()

# Use grey scale
b + geom_point(aes(color = cyl, shape = cyl)) + scale_color_grey() + theme_minimal()

#####################################################
##Add regression line or smoothed conditional mean###
#####################################################
#geom_smooth(), geom_abline()
#alpha, color, fill, shape, linetype, size
#geom_smooth(method = "auto")
#method:loess->local regression, lm-> linear regression

# Add regression line
b + geom_point() + geom_smooth(method = lm)

# Point + regression line
# Remove the confidence interval
b + geom_point() + geom_smooth(method = lm, se = FALSE)

# loess method, local regression fitting
b + geom_point() + geom_smooth()

# Change the color and shape by groups Âêß
b + geom_point(aes(color = cyl, shape = cyl)) + geom_smooth(aes(color = cyl, fill = cyl), method = lm)

# Remove confidence intervals
# Extend the regression lines: fullrage
b + geom_point(aes(color = cyl, shape = cyl)) + geom_smooth(aes(color = cyl), method = lm, se = FALSE, fullrange = TRUE)

# Add marginal rugs to a scatter plot
#geom_rug(sides = "bl")
# sides: a string, "trbl", top, right, bottom, left.
# Add marginal rugs
b + geom_point() + geom_rug()

# Change the color by group
b + geom_point(aes(color = cyl)) + geom_rug(aes(color = cyl))

# Add marginal rugs using faithful data
data(faithful)
faithful <- as_data_frame(faithful)
faithful
ggplot(faithful, aes(x = eruptions, y = waiting)) + geom_point() + geom_rug()

# Jitter points to reduce overplotting
# geom_jitter(), position_jitter()
#alpha, color, fill, shape, size

# Use mpg data
p <- ggplot(mpg, aes(displ, hwy))

# Default sactter plot
p + geom_point()

# Use jitter to reduce overplotting
p + geom_jitter(position = position_jitter(width = 0.5, height = 0.5))
select(mpg, displ, hwy) %>% arrange(-hwy) %>% filter(displ == 1.9)


##
#Text annotation
#geom_text()
#label, alpha, angle, color, family, fontface, hjust, lineheight, size, vjust

b + geom_text(aes(label = rownames(mtcars)), size = 3)

```

## Continuous bivariate distribution

* geom_bin2d()
* geom_hex()
* geom\_density\_2d()


```{r}
c <- ggplot(diamonds, aes(carat, price))
# Add heatmap of 2d bin counts
# geom_bin2d produce a scatter plot with rectangular bins.
# stat_bin_2d(), stat_summary_2d()
# max, xmin, ymax, ymin, alpha, color, fill, linetype, size
c + geom_bin2d()

# Change the number of bins
c + geom_bin2d(bins = 15)

# Specify the width of bins
c + geom_bin2d(binwidth = c(1,1000))
c + stat_bin_2d()
c + stat_summary_2d(aes(z = depth))

# Add hexagon bining
#geom_hex()
# stat_bin_hex(), stat_summary_hex()
# alpha, color, fill, size
require(hexbin)
c + geom_hex()

# Change the number of bins
c + geom_hex(bins = 10)
c + stat_bin_hex()
c + stat_summary_hex(aes(z = depth))

# 2D density estimation
# geom_density_2d()
# stat_density_2d()
# alpha, color, linetype, size

# Scatter plot
sp <- ggplot(faithful, aes(x = eruptions, y = waiting))
select(faithful, eruptions, waiting)
# Default plot
sp + geom_density_2d(color = "#E7B800")
# Add points
sp + geom_point(color = "#00AFBB") + geom_density_2d(color = "#E7B800")
# Use stat_density_2d with geom = "polygon"
sp + geom_point() + stat_density_2d(aes(fill = ..level..), geom = "polygon")
# Change the gradient color
sp + geom_point() + stat_density_2d(aes(fill = ..level..), geom = "polygon") + scale_fill_gradient(low = "#00AFBB", high = "#FC3E07")
# Gradient
```

## Two variables: Discrete X, Discrete Y
geom_jitter  
alpha, color, fill, shape, size  
```{r}
ggplot(diamonds, aes(cut, color)) + geom_jitter(aes(color = cut), size = 0.5)
select(diamonds, cut, color)
```


# Plot Two Variables - X & Y: Discrete X and Continuous Y

* geom_boxplot()
* geom_violin()
* geom_dotplot()
* geom_jitter()
* geom_line()
* geom_bar()

```{r}
data("ToothGrowth")
ToothGrowth$dose <- as.factor(ToothGrowth$dose)
ToothGrowth <- as_data_frame(ToothGrowth)
ToothGrowth
e <- ggplot(ToothGrowth, aes(x = dose, y = len))
```

## Box Plots

**alpha, color, linetype, shape, size, fill**  
`geom_boxplot(outlier.colour = "black", outlier.shape = 16, outlier.size = 2, notch = FALSE)`

```{r}
# Basic box plot
e + geom_boxplot()
# Rotate the box plot
e + geom_boxplot() + coord_flip()
# Notched box plot
e + geom_boxplot(notch = TRUE)
# Box plot with mean points
e + geom_boxplot() + stat_summary(fun.y = mean, geom = "point", shape = 18, size = 4, color = "blue")

# chose which item to display
e + geom_boxplot() + scale_x_discrete(limits = c("0.5", "2"))
# change default order of items
e + geom_boxplot() + scale_x_discrete(limits = c("2", "0.5", "1"))

e + stat_boxplot(coeff = 1.5)

# change the color by group
# box plot outline and fill colors can be automatically controlled by the levels of the grouping variable *dose*

# Use single color
e + geom_boxplot(color = "black", fill = "steelblue")

# Change outline colors by dose (groups)
e + geom_boxplot(aes(color = dose))

# Change the fill color by dose (groups)
e + geom_boxplot(aes(fill = dose))

# Change munually outline colors:
# Use custom color palettes
e2 <- e + geom_boxplot(aes(color = dose)) + theme_minimal()
e2 + scale_color_manual(values = c("#999999", "#E69F00", "#56B4E9"))

# Use brewer color palettes
e2 + scale_color_brewer(palette  = "Dark2")

# Use grey scale
e2 + scale_color_grey()

## Change manually by fill color
# Use the custom color palettes
e3 <- e + geom_boxplot(aes(fill = dose)) + theme_minimal()
e3 + scale_fill_manual(values = c("#999999", "#E69F00", "#56B4E9"))

# Use brewer color palettes
e3 + scale_fill_brewer(palette = "Dark2")

# Use grey color
e3 + scale_fill_grey()


## Boxplot with multiple groups
#The grouping variable *dose* and *supp* are used:

# Change box plot colors by groups
e + geom_boxplot(aes(fill = supp))
# Change the position
e + geom_boxplot(aes(fill = supp), position = position_dodge(1.1))
# Change the fill color
e + geom_boxplot(aes(fill = supp), position = position_dodge(1.1)) + scale_fill_brewer("BrBG")

```




## Violin Plots
Violin plots is similar to boxplot, except that they also show the kernel probability density of the data at different values. Tipically, violin plots will include a marker for the median of the data and a box indicating the interquartile range, as in standard boxplots.

**alpha, color, fill, linetype, size, and fill**

```{r violin plot}
# Basic plot
e + geom_violin()

# Rotate the violin plot
e + geom_violin() + coord_flip()

# Set trim argument to FALSE
e + geom_violin(trim = FALSE, fill = "steelblue")

## Add summary statistics
# Funtion stat_summary can be used to add mean/median points and more on a violin plot

# Add mean and median points: use fun.y = mean or fun.y = median
e + geom_violin(trim = FALSE) + stat_summary(fun.y = mean, geom = "point", shape = 23, size = 2, color = "blue")

# Add mean points +/- SD
# Use geom = "pointrange" or geom = "crossbar"
e + geom_violin(trim = FALSE) + stat_summary(fun.data = "mean_sdl", fun.args = list(mult = 1), geom = "pointrange", color = "red")
# The function mean_sdl is used for adding mean and standard deviation. 
# It computes the mean plus or minus a constant times the standard deviation. The constant is specified using the argument mult (mult = 1). Default mult = 2.
# The mean +/- SD can be added as crossbar or a pointrange. 


# Combine with box plot to add median and quartiles
e + geom_violin(trim = FALSE) + geom_boxplot(width = 0.2)

## Change colors by groups
# The color and fill can be automatically controlled by the levels  of the grouping variable dose

# Change the outline colors by dose (groups)
e + geom_violin(aes(color = dose), trim = FALSE)

# Change the fill color by dose
e  + geom_violin(aes(fill = dose), trim = FALSE)

# Change outline and fill color manually.
e2 <- e + geom_violin(aes(color = dose), trim = FALSE) + theme_minimal()
e2 + scale_color_brewer(palette = "Dark2")

# Change manually fill colors
e3 <- e + geom_violin(aes(fill = dose), trim = FALSE) + theme_minial()
e3 + scale_fill_brewer(palette = "Dark2")

## Violin plot with multiple groups
# Change the color by groups
e + geom_violin(aes(fill = supp), trim = FALSE)

# Change fill colors
e + geom_violin(aes(fill = supp), trim = FALSE) + scale_fill_brewer(palette = "Dark2")
```

## Dot plots
`geom_dotplot(), stat_summary()`  
**alpha, color, dotsize and fill**
```{r dot plot}
#Basic dot plot
e + geom_dotplot(binaxis ="y", stackdir = "center")

# Change dotsize and stack ratio
e + geom_dotplot(binaxis = "y", stackdir = "center", stackratio = 1.5, dotsize = 1.1)

# stat_summary can be used to add mean/median points and more on a violin plot
# Add mean and median points: use fun.y = mean or fun.y = median
e + geom_dotplot(binaxis = "y", stackdir = "center") + stat_summary(fun.y = mean, geom = "point", shape = 18, size = 3, color = "red")

# Add mean points with +/- SD
# Use geom = "pointrange" or geom = "crossbar"
e + geom_dotplot(binaxis = "y", stackdir = "center") + stat_summary(fun.data = "mean_sdl", fun.args = list(mult = 1), geom = "pointrange", color = "red")

## Combine with box plot and dot plot:
# Combine with boxplot
e + geom_boxplot() + geom_dotplot(binaxis = "y", stackdir ="center")

# Combine with violin plot
e + geom_violin(trim = FALSE) + geom_dotplot(binaxis = "y", stackdir ="center")

# Dotplot + violin plot + stat summary
e + geom_violin(trim = FALSE) + geom_dotplot(binaxis = "y", stackdir ="center") + stat_summary(fun.data = "mean_sdl", fun.args = list(mult = 1), geom = "pointrange", color = "red", shape = 11)

# use scale to change the outlien and fill color automatically controlled byt the levels of the grouping variable dose
# scale_color_munual(), scale_color_brewer(), scale_color_grey()
# scale_fill_munual(), sclae_fill_brewer(), scale_fill_grey()

e + geom_dotplot(binaxis = "y", stackdir = "center", aes(color = dose), fill = "white") + theme_minimal()

## dotplot with multiple groups
# just like boxplot and violin plot
```

## Stripcharts
Stripecharts are also known as one dimensional scatter plots. These plots are suitable compared to box plot when sample sizes are small.  
`geom_jitter(), stat_summary()`  
**alpha, color, size and fill**
```{r stripecharts}
e + geom_jitter()

# Change the position
# 0.2 is the degree of jitter in x direction
e + geom_jitter(position = position_jitter(0.2))

# Change point shapes and size
e  + geom_boxplot()+ geom_jitter(position = position_jitter(0.2), shape = 11, size = 1.2)

# Add summary statistics
# Add mean or median point
e + geom_jitter(position = position_jitter(0.2)) + stat_summary(fun.y = mean, geom = "point", shape = 18, size = 3, color = "red")

# use geom = "pointrange"
e + geom_jitter(position = position_jitter(0.2)) + stat_summary(fun.data = "mean_sdl", fun.args = list(mult = 1), shape = 18, color = "red")

# Combine with boxplot and violin plot
e + geom_violin(trim = FALSE) + geom_jitter(position = position_jitter(0.1)) + stat_summary(fun.data = "mean_sdl", fun.args = list(mult = 1), shape = 18, color = "red")

# Change point shape by group
e + geom_jitter(aes(shape = dose), position = position_jitter(0.2)) + scale_shape_manual(values = c(1,17,19))

# Change color by groups
e + geom_jitter(aes(color = dose, shape = dose), position = position_jitter(0.2)) + theme_minimal()

# Change the outlien and fill color by scale

##Stripchar with multiple groups
#Change colors and shapes by groups
e + geom_jitter(aes(color = supp, shape = supp), position = position_jitter(0.2))

# Add boxplot
e + geom_boxplot(aes(color = supp), position = position_dodge()) + geom_jitter(aes(color = supp, shape = supp), position = position_jitter(0.2)) + theme_minimal()
```

## Line plots
In a line graph, observations are ordered by x value and connected.  
x value can be:

* date: for a time series data
* texts
* discrete numeric values
* continuous numeric values

`geom_line(), geom_path(), geom_step()`

**alpha, color, linetype and size**

```{r line}
df <- data.frame(dose = c("D0.5", "D1", "D2"), len = c(4.2,10, 29.5))
df2 <- data.frame(supp = rep(c("VC", "OJ"), each = 3), dose = rep(c("D0.5", "D1", "D2"),2 ), len = c(6.8, 15, 33, 4.2, 10, 29.5))

p<- ggplot(data = df, aes(x = dose, y = len, group = 1))
p + geom_line() + geom_point()

# Change the line color and line type
p + geom_line(linetype = "dashed", color = "steelblue") + geom_point(color = "steelblue")

# use geom_step()
p + geom_step() + geom_point()

# use paht
p + geom_path() 

# Line plot with multiple groups
# line tpye and point shape automatically controlled by groups.
p <- ggplot(df2, aes(x = dose, y= len, group = supp))
p + geom_line(aes(linetype = supp)) + geom_point(aes(shape = supp))

# Change the line type, point shapes and colors
p + geom_line(aes(linetype = supp, color = supp)) + geom_point(aes(shape = supp, color = supp)) + scale_color_brewer(palette = "Dark2")

# X-axis is date; use economics
head(economics)
ggplot(data = economics, aes(x = date, y = pop)) + geom_line()

# subset data
ss <- subset(economics, date > as.Date("2006-1-1"))
ggplot(data = ss, aes(x = date, y = pop)) + geom_line()

# line size
ggplot(data = economics, aes(x = date, y = pop, size = unemploy/ pop)) + geom_line()

# multiple time series data:
# Solution 1
ggplot(economics, aes(x = date)) + geom_line(aes(y = psavert, color = "darkred")) + geom_line(aes(y = uempmed), color = "steelblue", linetype = "twodash") + theme_minimal()

# Solution 2: melt by date

# Area plot
ggplot(economics, aes(x = date)) + geom_area(aes(y = psavert), fill = "#999999", color = "#999999", alpha = 0.5) + geom_area(aes(y = uempmed), fill = "#E69F00", color = "#E69F00", alpha = 0.5) + theme_minimal()
```

## Bar plots
`geom_bar()`  
**alpha, color, fill, linetype and size**
```{r bar plot}
df <- data.frame(dose = c("D0.5", "D1", "D2"), len = c(4.2,10, 29.5))
df2 <- data.frame(supp = rep(c("VC", "OJ"), each = 3), dose = rep(c("D0.5", "D1", "D2"),2 ), len = c(6.8, 15, 33, 4.2, 10, 29.5))

f <- ggplot(df, aes(x = dose, y = len))

f + geom_bar(stat = "identity")
#Change fill color and add labels at the top
f + geom_bar(stat= "identity", fill = "steelblue") + geom_text(aes(label = len), vjust = -0.3, size = 3.5) + theme_minimal()
f + geom_bar(stat= "identity", fill = "steelblue") + geom_text(aes(label = len), vjust = 1.6, size = 3.5, color = "white") + theme_minimal() + scale_x_discrete(limits = c("D2", "D0.5", "D1"))

# change the color by groups
f + geom_bar(aes(color = dose), stat = "identity", fill = "white")


#bar plot with multiple groups
g <- ggplot(data =df2, aes(x = dose, y = len, fill = supp))

# Statcked bar plot
g + geom_bar(stat = "identity")
# Use position = position_dodge()
g + geom_bar(stat = "identity", position = position_dodge()) + geom_text(aes(label = len), vjust = 1.6, color = "white", position = position_dodge(0.9), size = 3.5)

library(dplyr)
library(plyr)
df_sorted <- arrange(df2, dose, supp)
df_cumsum <- ddply(df_sorted, "dose", transform, label_ypos = cumsum(len))

# Create the bar plot
ggplot(data = df_cumsum, aes(x = dose, y = len, fill = supp)) + geom_bar(stat = "identity") + geom_text(aes(label = len, y = label_ypos), vjust = 1.6, color = "white", size = 3.5)

```











